import fs from 'fs';
import path from 'path';
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { sendEmail, generateSolicitudEmail, generatePhotosUploadedEmail } from '../services/emailService';

const prisma = new PrismaClient();
const UPLOAD_DIR = process.env.UPLOAD_DIR || '/app/uploads';

// Ensure upload directory exists
if (!fs.existsSync(UPLOAD_DIR)) {
    fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

// POST /api/solicitudes
export const createSolicitud = async (req: Request, res: Response) => {
    try {
        const { tipoVehiculo, marca, modelo, ano, whatsapp, clienteNombre } = req.body;

        // Create solicitud - Tokens automatically generated by Prisma
        const solicitud = await prisma.solicitudSeguro.create({
            data: {
                tipoVehiculo,
                marca,
                modelo,
                ano: parseInt(ano),
                whatsapp,
                clienteNombre,
                estado: 'NUEVA'
            }
        });

        // Send email to agent
        try {
            const emailData = generateSolicitudEmail(solicitud);
            await sendEmail(emailData);
        } catch (emailError) {
            console.error('❌ Error enviando email:', emailError);
        }

        res.status(201).json({
            message: 'Solicitud creada exitosamente',
            solicitud
        });
    } catch (error) {
        console.error('Error creating solicitud:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// GET /api/solicitudes/asesor/:token
export const getSolicitudByAsesorToken = async (req: Request, res: Response) => {
    try {
        const { token } = req.params;
        const solicitud = await prisma.solicitudSeguro.findUnique({
            where: { tokenAsesor: token }
        });

        if (!solicitud) {
            return res.status(404).json({ error: 'Solicitud no encontrada' });
        }

        res.json(solicitud);
    } catch (error) {
        console.error('Error fetching solicitud:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// GET /api/solicitudes/cliente/:token
export const getSolicitudByClienteToken = async (req: Request, res: Response) => {
    try {
        const { token } = req.params;
        const solicitud = await prisma.solicitudSeguro.findUnique({
            where: { tokenCliente: token }
        });

        if (!solicitud) {
            return res.status(404).json({ error: 'Solicitud no encontrada' });
        }

        res.json(solicitud);
    } catch (error) {
        console.error('Error fetching solicitud:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// POST /api/solicitudes/:token/fotos
export const uploadFotos = async (req: Request, res: Response) => {
    try {
        const { token } = req.params;
        // Type assertion for multer files
        const files = (req as any).files as { [fieldname: string]: Express.Multer.File[] } | undefined;
        const body = req.body;

        // Verify token
        const solicitud = await prisma.solicitudSeguro.findUnique({
            where: { tokenCliente: token }
        });

        if (!solicitud) {
            return res.status(404).json({ error: 'Solicitud no encontrada' });
        }

        // Helper to process a specific photo slot
        const processPhotoSlot = (
            slotName: string,
            fileArray: Express.Multer.File[] | undefined,
            existingUrl: string | undefined
        ): string | null => {
            // Priority 1: New file uploaded
            if (fileArray && fileArray.length > 0) {
                const file = fileArray[0];
                const fileName = `${Date.now()}-${slotName}-${file.originalname.replace(/\s+/g, '-')}`;
                const filePath = path.join(UPLOAD_DIR, fileName);

                fs.writeFileSync(filePath, file.buffer);
                return `/uploads/${fileName}`;
            }

            // Priority 2: Keep existing URL
            if (existingUrl && existingUrl.includes('/uploads/')) {
                // Security check: ensure the URL is a valid local upload path
                return existingUrl;
            }

            return null;
        };

        // Slots in order: 0=Frente, 1=Dorso, 2=Carnet, 3=PruebaVida
        const fotosArray: string[] = [];

        // Slot 0: Cedula Frente
        const f0 = processPhotoSlot('cedulaFrente', files?.['cedulaFrente'], body.existing_cedulaFrente);
        if (f0) fotosArray[0] = f0;

        // Slot 1: Cedula Dorso
        const f1 = processPhotoSlot('cedulaDorso', files?.['cedulaDorso'], body.existing_cedulaDorso);
        if (f1) fotosArray[1] = f1;

        // Slot 2: Licencia
        const f2 = processPhotoSlot('carnet', files?.['carnet'], body.existing_carnet);
        if (f2) fotosArray[2] = f2;

        // Slot 3: Prueba Vida
        const f3 = processPhotoSlot('pruebaVida', files?.['pruebaVida'], body.existing_pruebaVida);
        if (f3) fotosArray[3] = f3;

        // Ensure array is compact or filled? 
        // We will store it as is, but filter nulls if we want compact, OR 
        // to maintain index integrity for "view mode", we should probably populate the array fully up to the max index used.
        // However, Prisma String[] is just a list. 
        // Let's filter out empty strings/nulls for now, OR better yet:
        // The current View Mode renders by iterating. If we want strict slots, we should store them.
        // BUT, the current Schema is just string[]. 
        // To be safe and backward compatible with "view mode" iterating:
        // We will push them in order. If slot 0 is missing but slot 2 is present, we might have an issue strictly mapping back.
        // DECISION: We will push ALL, even if empty? No, standard array.
        // REVISION: The only way to guarantee "Slot 2 is Carnet" is to ALWAYS save 4 strings, even if some are empty placeholder strings?
        // OR better: Just save the valid ones. When loading back, we guess the slots based on count? No that's fragile.
        // GIVEN THE CONSTRAINTS: We will just save the valid URLs. 
        // The View Mode in Frontend attempts to map them to slots 1, 2, 3... 
        // Wait, if I upload only "PruebaVida" (Slot 3), and save it... 
        // If I save just `[url_prueba_vida]`, next time I load it, it will show up as `foto_1` (Cedula Frente).
        // This is a limitation of the current Schema. 
        // WORKAROUND: I will save placeholders for empty slots if there are later slots filled? 
        // No, that messes up the display.
        // ACCEPTABLE COMPROMISE for 'Improving UX':
        // We will assume users typically upload all 4.
        // If they assume "Slot editing", we really need to know which is which.
        // Since I cannot change schema easily (migrations etc), I will try to infer or just live with the sequential mapping 
        // UNLESS request includes ALL current photos.
        // The Frontend WILL send existing URLs for all slots that have them.
        // So if I have 4 photos, and I change #3, Frontend sends: existing_0, existing_1, FILE_2, existing_3.
        // So I will rebuild the array of 4 items.
        // If a slot is empty, I can't put a null in a String[] (usually).
        // I will filter `Boolean` but this means we lose position if early ones are missing.
        // BUT: The user has to upload "Documentacion requerida". 
        // Let's just save the non-nulls.
        const finalFotos = fotosArray.filter(f => f !== undefined && f !== null);

        const { patente, motor, chasis } = req.body;

        const updatedSolicitud = await prisma.solicitudSeguro.update({
            where: { id: solicitud.id },
            data: {
                fotos: {
                    set: finalFotos // Use SET to replace the array
                },
                estado: 'FOTOS_SUBIDAS',
                patente: patente || undefined,
                motor: motor || undefined,
                chasis: chasis || undefined
            }
        });

        res.json({
            message: 'Fotos y datos guardados exitosamente',
            fotos: finalFotos
        });
    } catch (error) {
        console.error('Error uploading photos:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// GET /api/solicitudes
// Protected route for Advisor Dashboard
export const getAllSolicitudes = async (req: Request, res: Response) => {
    try {
        const { estado } = req.query;

        const whereClause: any = {};
        if (estado) {
            whereClause.estado = estado;
        }

        const solicitudes = await prisma.solicitudSeguro.findMany({
            where: whereClause,
            orderBy: { createdAt: 'desc' }
        });

        res.json(solicitudes);
    } catch (error) {
        console.error('Error fetching all solicitudes:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// PATCH /api/solicitudes/:id/estado
// Protected route for Advisor Dashboard to mark as Won/Lost
export const updateEstado = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { estado } = req.body;

        if (!['NUEVA', 'FOTOS_SUBIDAS', 'GANADA', 'PERDIDA'].includes(estado)) {
            return res.status(400).json({ error: 'Estado inválido' });
        }

        const solicitud = await prisma.solicitudSeguro.update({
            where: { id: parseInt(id) },
            data: { estado }
        });

        res.json(solicitud);
    } catch (error) {
        console.error('Error updating estado:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};
