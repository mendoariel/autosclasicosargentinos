import fs from 'fs';
import path from 'path';
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { sendEmail, generateSolicitudEmail, generatePhotosUploadedEmail, testEmailConfiguration } from '../services/emailService';

const prisma = new PrismaClient();
const UPLOAD_DIR = process.env.UPLOAD_DIR || '/app/uploads';

// Ensure upload directory exists
if (!fs.existsSync(UPLOAD_DIR)) {
    fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

// POST /api/solicitudes
export const createSolicitud = async (req: Request, res: Response) => {
    try {
        const { tipoVehiculo, marca, modelo, ano, whatsapp, clienteNombre } = req.body;

        // Create solicitud - Tokens automatically generated by Prisma
        const solicitud = await prisma.solicitudSeguro.create({
            data: {
                tipoVehiculo,
                marca,
                modelo,
                ano: parseInt(ano),
                whatsapp,
                clienteNombre,
                estado: 'NUEVA'
            }
        });

        // Send email to agent
        try {
            const emailData = generateSolicitudEmail(solicitud);
            await sendEmail(emailData);
        } catch (emailError) {
            console.error('❌ Error enviando email:', emailError);
        }

        res.status(201).json({
            message: 'Solicitud creada exitosamente',
            solicitud
        });
    } catch (error: any) {
        console.error('Error creating solicitud:', error);
        res.status(500).json({
            error: 'Error interno del servidor',
            message: error.message,
            stack: error.stack,
            details: error
        });
    }
};

// GET /api/solicitudes/asesor/:token
export const getSolicitudByAsesorToken = async (req: Request, res: Response) => {
    try {
        const { token } = req.params;
        const solicitud = await prisma.solicitudSeguro.findUnique({
            where: { tokenAsesor: token }
        });

        if (!solicitud) {
            return res.status(404).json({ error: 'Solicitud no encontrada' });
        }

        res.json(solicitud);
    } catch (error) {
        console.error('Error fetching solicitud:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// GET /api/solicitudes/cliente/:token
export const getSolicitudByClienteToken = async (req: Request, res: Response) => {
    try {
        const { token } = req.params;
        const solicitud = await prisma.solicitudSeguro.findUnique({
            where: { tokenCliente: token }
        });

        if (!solicitud) {
            return res.status(404).json({ error: 'Solicitud no encontrada' });
        }

        res.json(solicitud);
    } catch (error) {
        console.error('Error fetching solicitud:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// POST /api/solicitudes/:token/fotos
export const uploadFotos = async (req: Request, res: Response) => {
    try {
        const { token } = req.params;
        // Type assertion for multer files
        const files = (req as any).files as { [fieldname: string]: Express.Multer.File[] } | undefined;
        const body = req.body;

        // Verify token
        const solicitud = await prisma.solicitudSeguro.findUnique({
            where: { tokenCliente: token }
        });

        console.log(`[UPLOAD] Upload request for token: ${token}`);
        if (files) {
            console.log(`[UPLOAD] Files received: ${Object.keys(files).join(', ')}`);
            Object.keys(files).forEach(key => {
                console.log(`[UPLOAD] Field ${key}: ${files[key].length} files`);
            });
        } else {
            console.log('[UPLOAD] No files received');
        }

        if (!solicitud) {
            console.error(`[UPLOAD] Solicitud not found for token: ${token}`);
            return res.status(404).json({ error: 'Solicitud no encontrada' });
        }

        // Helper to process a specific photo slot
        const processPhotoSlot = (
            slotName: string,
            fileArray: Express.Multer.File[] | undefined,
            existingUrl: string | undefined
        ): string | null => {
            // Priority 1: New file uploaded
            if (fileArray && fileArray.length > 0) {
                const file = fileArray[0];
                const fileName = `${Date.now()}-${slotName}-${file.originalname.replace(/\s+/g, '-')}`;
                const filePath = path.join(UPLOAD_DIR, fileName);

                fs.writeFileSync(filePath, file.buffer);
                return `/uploads/${fileName}`;
            }

            // Priority 2: Keep existing URL
            if (existingUrl && existingUrl.includes('/uploads/')) {
                // Security check: ensure the URL is a valid local upload path
                return existingUrl;
            }

            return null;
        };

        // Slots in order: 0=Frente, 1=Dorso, 2=Carnet, 3=PruebaVida
        const fotosArray: string[] = [];

        // Slot 0: Cedula Frente
        const f0 = processPhotoSlot('cedulaFrente', files?.['cedulaFrente'], body.existing_cedulaFrente);
        if (f0) fotosArray[0] = f0;

        // Slot 1: Cedula Dorso
        const f1 = processPhotoSlot('cedulaDorso', files?.['cedulaDorso'], body.existing_cedulaDorso);
        if (f1) fotosArray[1] = f1;

        // Slot 2: Licencia
        const f2 = processPhotoSlot('carnet', files?.['carnet'], body.existing_carnet);
        if (f2) fotosArray[2] = f2;

        // Slot 3: Prueba Vida
        const f3 = processPhotoSlot('pruebaVida', files?.['pruebaVida'], body.existing_pruebaVida);
        if (f3) fotosArray[3] = f3;

        // NEW: Handle generic 'fotos' (e.g. from Cotizar page)
        const genericFotos = files?.['fotos'];
        if (genericFotos && genericFotos.length > 0) {
            genericFotos.forEach(file => {
                const fileName = `${Date.now()}-general-${file.originalname.replace(/\s+/g, '-')}`;
                const filePath = path.join(UPLOAD_DIR, fileName);
                fs.writeFileSync(filePath, file.buffer);
                fotosArray.push(`/uploads/${fileName}`);
            });
        }

        const finalFotos = fotosArray.filter(f => f !== undefined && f !== null);

        const { patente, motor, chasis } = req.body;

        // Check if any documentation photos were uploaded
        const hasDocPhotos = ['cedulaFrente', 'cedulaDorso', 'carnet', 'pruebaVida'].some(
            field => files?.[field] && files[field].length > 0
        );

        const updateData: any = {
            fotos: { set: finalFotos },
            patente: patente || undefined,
            motor: motor || undefined,
            chasis: chasis || undefined
        };

        // Only upgrade status if documentation photos are present
        if (hasDocPhotos) {
            updateData.estado = 'FOTOS_SUBIDAS';
        }

        const updatedSolicitud = await prisma.solicitudSeguro.update({
            where: { id: solicitud.id },
            data: updateData
        });

        res.json({
            message: 'Fotos y datos guardados exitosamente',
            fotos: finalFotos
        });
    } catch (error) {
        console.error('Error uploading photos:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// GET /api/solicitudes
// Protected route for Advisor Dashboard
export const getAllSolicitudes = async (req: Request, res: Response) => {
    try {
        const { estado } = req.query;

        const whereClause: any = {};
        if (estado) {
            whereClause.estado = estado;
        }

        const solicitudes = await prisma.solicitudSeguro.findMany({
            where: whereClause,
            orderBy: { createdAt: 'desc' }
        });

        res.json(solicitudes);
    } catch (error) {
        console.error('Error fetching all solicitudes:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};

// PATCH /api/solicitudes/:id/estado
// Protected route for Advisor Dashboard to mark as Won/Lost
export const updateEstado = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { estado } = req.body;

        if (!['NUEVA', 'FOTOS_SUBIDAS', 'GANADA', 'PERDIDA'].includes(estado)) {
            return res.status(400).json({ error: 'Estado inválido' });
        }

        const solicitud = await prisma.solicitudSeguro.update({
            where: { id: parseInt(id) },
            data: { estado }
        });

        res.json(solicitud);
    } catch (error) {
        console.error('Error updating estado:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
};
// DEBUG Endpoint
export const debugEmail = async (req: Request, res: Response) => {
    try {
        const result = await testEmailConfiguration();
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: 'Internal debug error', details: error });
    }
};

export const debugDb = async (req: Request, res: Response) => {
    try {
        await prisma.$connect();
        const count = await prisma.solicitudSeguro.count();
        res.json({
            success: true,
            message: 'Database connection successful',
            table: 'solicitudSeguro',
            count
        });
    } catch (error: any) {
        res.status(500).json({
            success: false,
            error: 'Database connection failed',
            details: error.message,
            stack: error.stack
        });
    }
};
